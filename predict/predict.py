import _init_paths
import numpy as np
import tensorflow as tf
import tensorflow.keras.backend as K
import cv2
import seaborn as sns
import matplotlib.pyplot as plt
from skimage.transform import resize
from viz import VizImage, Shower, VizAngle
from mymodel.Unet import GetModel, WrapperModel
from mydata.dataset import MyDataset
from tqdm import tqdm

def ComputeValidInterval(prob, threshold_prob=0.5, threshold_interval=10):
    '''
    merge probability indexes together that belongs to the same angle
    inputs:
        prob: probability distribution generated by the network, ndarray of shape (360,)
        threshold_prob: probability smaller than this value are ignored
        threshold_interval: two angles with distance smaller than this value are merged into one angle
    outputs:
        a list of tuples indicating the valid indices for each angle:
        [(angle1_idx_begin, angle1_idx_end), (angle2_idx_begin, angle2_idx_end), ...]
        
    '''

    mask_current = prob > threshold_prob
    mask_left = np.roll(mask_current, 1)
    mask_right = np.roll(mask_current, -1)
    begin = np.logical_and(mask_current, np.logical_not(mask_left))
    end = np.logical_and(mask_current, np.logical_not(mask_right))
    begin = begin.astype(np.int8).nonzero()[0]
    end = end.astype(np.int8).nonzero()[0]
    if len(begin) == 0 and len(end) == 0: 
        return [] # the prediction is empty
    if begin[0] > end[0]: end = np.roll(end, -1) # one interval covers value 0
    
    interval_dist = begin - np.roll(end, 1)
    interval_dist[interval_dist<0] += 360
    selected = interval_dist > threshold_interval
    begin = begin[selected]
    end = end[np.roll(selected, -1)]
    if begin[0] > end[0]: end = np.roll(end, -1)
    return list(zip(begin, end))

def GetUnitVectors():
    radians = np.arange(360) * np.pi / 180.0
    cos = np.cos(radians)
    sin = np.sin(radians)
    units =  cos + sin * 1j
    return units

def NMS(prob, unit=None, threshold_prob=0.5, threshold_interval=10):
    valid_interval =ComputeValidInterval(prob, threshold_prob=threshold_prob, threshold_interval=threshold_interval)
    if unit is None: unit = GetUnitVectors()
    pred_vector = prob * unit
    result = []
    for begin, end in valid_interval:
        if begin <= end:
            result.append(np.sum(pred_vector[begin:end]))
        else:
            result.append(np.sum(pred_vector[:end]) + np.sum(pred_vector[begin:]))
    result = np.angle(result, deg=True)
    result[result<0] += 360
    return result.round(1)

def GetModelAndData():
    ds = MyDataset(batch_size = 1)
    ds_tr, ds_val = ds.GetDataset()
    
    m = GetModel()
    wrapper = WrapperModel(m, is_training=True)
    import tensorflow.keras.models as KM
    
    for data in ds_tr.take(1): # build model
        _ = wrapper(data)
        
    wrapper.load_weights('unet.h5')
    print('model loaded')
    model_train = wrapper.m
    inp = model_train.inputs[0] # input image
    oup = model_train.outputs[1]
    model = KM.Model(inputs=inp, outputs=oup)
    return model, ds_tr, ds_val
    
if __name__ == '__main__':
    model, ds_tr, ds_val = GetModelAndData()
    
    for data in tqdm(ds_val.take(100)):
        image = data['image'][0, ...].numpy()
        weight = data['weight'][0, ...].numpy()
        prob_gt = data['label'][0, ...].numpy() # (32, 32, 360)
        prob_pred = model.predict_on_batch(data['image'])[0] # (32, 32, 360)
        
        pts = np.sum(weight, axis=-1)
        pts[pts!=0] = 1
        ys, xs = np.nonzero(pts)
        idx_y, idx_x = ys[0], xs[0]
        prob_gt = prob_gt[idx_y, idx_x, :] # (360,)
        prob_pred = prob_pred[idx_y, idx_x, :] # (360,)
        
        pred = NMS(prob_pred)
        gt = np.nonzero(prob_gt)[0]
        title_pred = 'pred: {}'.format(pred)
        title_gt = 'gt: {}'.format(gt)
        
        show_list = []
        show_list.append(VizImage(image, title='image'))
        # show_list.append(VizImage(pts, title='points'))
        show_list.append(VizAngle(prob_gt, title=title_gt))
        show_list.append(VizAngle(prob_pred, title=title_pred))
        shower = Shower(show_list)
        shower.Show()